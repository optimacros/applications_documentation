# Инструкция программиста для создания python приложений для гипервизора.

Цель данной инструкции - дать подробную информацию об особенностях разработки и запуска python приложений на гипервизоре внешних задач для программиста.

---

### Список терминов и сокращений, используемых в инструкции.
- AM - Application Manager.
- HV - гипервизор (диспетчер) внешних задач.
- IPC - межпроцессная коммуникация. 
- Приложение - папка АМ, содержащая набор скриптов.
- Скрипт (python) - файл в папке приложения АМ с расширением .py или .py3
- Вэбхендлер - часть URL ресурса, задаваемая настройками приложения АМ
- WS - вэбсокет


## Общая информация

Гипервизор внешних приложений - это программный комплекс, созданный для запуска программного обеспечения в заданных условиях окружения с передаваемыми от АМ параметрами.

Application Manager взаимодействует с гипервизором внешних задач по IPC-протоколу, работающему на TCP-сокетах, а также HTTP и WS каналами.

В данной инструкции рассмотрен только запуск и особенности разработки скриптов, написанных на языке Python 3.

## Создание нового приложения в АМ

Экран с приложениями открывается автоматически при начале работы с Application Manager. Или к нему можно перейти, выбрав пункт Application в верхнем левом меню.

![Верхнее меню](images/python-user/image-1.png)

Приложение - это набор скриптов в папке. Название папки на данном этапе и является названием приложения.

Создать новое приложение в АМ можно выбрав пункт "Create new application" в контекстном меню, которое открывается по нажатию правой кнопки мыши в области списка приложений.

![Создание нового приложения](images/python-user/image.png)

При выборе этого пункта будет открыто модальное окно с формой параметров нового приложения.

![Заполнение параметров нового приложения](images/python-user/image-2.png)

Обязательным параметром в данный момент является только поле имя приложения - Application name *. После его заполнения станет доступна кнопка сохранения изменений "SAVE CHANGES".

Ниже поле имени приложения вы увидите также поле Application id, которое заполняетя АМ автоматически сгенерированным идентификатором. Его мы оставляем как есть.

### Вкладки "Executable Scripts" и "Web".

Executable Scripts содержит информацию об исполняемых скриптах приложения с их наименованиями и постоянными идентификаторами, присваиваемыми им. Идентификаторы исполняемых скриптов могут быть использованы как альтернатива их именам в различных ситуациях, которые будут описаны далее.

![Исполняемые скрипты приложения](images/python-user/image-3.png)

При создании нового приложения разработчики АМ решили автоматически создавать пустой исполняемый скрипт на языке TypeScript. Вы сможете удалить его после создания приложения, если не будете работать с ним.

Вкладка Web содержит форму для настройки параметров работы Application Manager в качестве Web-сервера.

Application Manager работает также и в качестве вэб-сервера для вашего приложения. Он может автоматически отдавать статические файлы, которые вы создаете в своем приложении, а также обрабатывать http-запросы, поступающие на задаваемые ваши адреса-вэбхендлеры.

Каждое приложение АМ имеет автоматически формируемый адрес:

https://Адрес-АМ/app/ИдентификаторПриложения/ИмяСтатическогоФайлаИлиВэбХэндлер

В поле "Path to directory with static files" указывается папка, в которой вы будете размещать статические html и др. файлы. Лучше создавать такую папку в приложении для улучшения его структуры.
Если вы не хотите создавать отдельную папку для статических файлов, необходимо указать в этом поле '/' и тогда АМ будет искать их в корне приложения.

![Поле имени папки статических файлов](images/python-user/image-4.png)

Далее идет список вэб-хендлеров.

Пока этот функционал ограничен при работе с python скриптами, но вы сможете использовать его для запуска python скриптов при обращении на заданный в вэбхенлдере http-запрос на заданный URL. АМ, получив запрос на этот вэбхендлер, запустит заданный скрипт, если он еще не запущен.  

Как было упомянуто выше, для создания приложения в АМ достаточно только заполнить поле с именем приложения.

Заполнив, для примера это поле значением App1
![Создание приложения App1](images/python-user/image-5.png)
и нажав кнопку "SAVE CHANGES" вы увидите в списке приложений папку с этим именем:

![Папка приложения в АМ](images/python-user/image-6.png) (и, возможно, фоновым рисунком, пока случайным)

Нажав на папку, вы попадете в среду разработки приложения Application Manager.

![Среда разработки Application Manager](images/python-user/image-7.png)

Интерфейс среды разработки может со временем измениться.

Верхнее меню служит для перехода к окну выбора приложений, установки глобальных параметров приложения, выбора темы и т.д.

Слева располагается основное окно редактора скриптов.

Справа располагается список файлов и папок приложения, меню для их создания, загрузки, обновления списка и т.д.

При выборе файла также появляются дополнительные опции меню (Запуск скрипта, Запуск скрипта с параметрами и т.д.) и активируются неактивные ранее:

![Меню управления файлами](images/python-user/image-8.png)

В нижней части среды находится область вывода консоли скриптов:

![Меню управления файлами](images/python-user/image-9.png)

А также меню быстрого перехода между окрытыми приложениями и статусная строка с текущими версиями фронтенда и бэкенда Application Manager (может понадобится при обращении к разработчикам АМ):

![Нижняя область АМ](images/python-user/image-10.png)

Механизм манипулирования скриптами python ничем не отличается от скриптов на языках JavaScript и TypeScript и любыми другими скриптами. 

Вы можете ознакомиться с ним в основном руководстве по Application Manager.

Для запуска python скриптов вы можете использовать кнопки запуска без параметров (с пустым словарем параметров) и с параметрами, задаваемыми при старте. 

Запуск python-скриптов через вэб-хэндлеры возможен, но обработка самих запросов python-скриптами пока не предусмотрена требованиями заказчика.

## Быстрый старт

В панели файлов приложения создайте новый скрипт:

![Добавление нового скрипта](images/python-user/image-11.png)

Назовем его test.py

![Именование нового скрипта python](images/python-user/image-12.png)

В списке файлов приложения у вас появится новый файл test.py, при его выборе слева вы можете редактировать его содержимое.

Для сохранения изменений используйте кнопку:

![Сохранение изменений скрипта](images/python-user/image-13.png)

которая активируется при изменениях, либо используйте сочетание клавиш Ctrl-S.

Чтобы АМ понимал, что это исполняемый скрипт, необходимо выделить его в списке и нажать кнопку Make executable:

![Сделать крипт исполняемым](images/python-user/image-15.png)

Если скрипт не будет помечен, как исполняемый, вы не сможете его запустить напрямую из панели АМ или назначить в вэб-хэндлере. 

**Внимание!** Если скрипт не помечен, как исполняемый вы не можете запустить его в панели АМ или использовать в вэб-хэндлере. Однако, вы можете импортировать его в другом исполняемом скрипте и код, указанный в нем для исполнения при импорте будет выполнен.

Добавим в наш скрипт знаменитое Hello world! и сохраним изменения:

![Простой скрипт Hello world!](images/python-user/image-14.png)

Проверим, как исполняется наш скрипт. Запустите его кнопкой запуска без параметров.

Код скрипта выполнится, в консоли АМ вы увидите результат работы (вывод на стандартный поток вывод из скрипта выводится в консоль АМ. При обычной печати - вывод производится в стандартный поток вывода):

![Результат исполнения скрипта](images/python-user/image-16.png)

В текущей версии консоли Application Manager вы можете видеть закладу с именем скрипта, выводившего информацию на печать в консоль, время его запуска, состояние (closed - при завершении или иное). В окне консоли вы видите, что скрипт вывел информацию на печать спустя 0.026 секунд после старта задачи.

В правой области консоли вы можете увидеть информационную панель задачи:

![Информация задачи](images/python-user/image-17.png)

**Внимание!** Информация из этой панели не передается задаче. В задаче вы можете получить лишь часть информации, передаваемой ей из AM при запуске.


## Особенности запуска скриптов в АМ.

При ручном старте скрипта из панели АМ при каждом запуске будет запускаться отдельный процесс выполнения кода этого скрипта - **задача** (технически, перед запуском самой задачи запускается сначала процесс-наблюдатель - observer, но это скрыто от пользователя).

Т.о., если вы запустите скрипт 5 раз через панель запуска АМ, то для каждого вашего клика запуска запустится отдельная задача в гипервизоре.

С текущими настройками по-умолчанию каждая задача имеет таймаут выполнения 300 секунд  (переменная окружения DEFAULT_TASK_TIMEOUT_SEC). Этот таймаут можно изменить, задав его при запуске в виде параметра "timeout" и указав количество секунд. Если указать значение меньше 0 (например, -1) то гипервизор не будет ограничивать задачу по времени ее выполнения.

Кроме того, с текущими настройками по-умолчанию процесс задачи не может занимать в памяти более 100 Мб (переменная окружения DEFAULT_TASK_MAX_MEMORY_MB). Вы также можете изменить этот параметр для конкретного скрипта при запуске с параметром "memoryLimit" и количеством мегабайт.


## Рабочее окружение python скриптов.

Гипервизор работает с собственном контейнере Docker, отдельном от АМ.

Каждая задача запускается в отдельном процессе.

Взаимодействие python задач друг с другом, если они запускаются на одном гипервизоре на данный момент никак не ограничивается. 

### Файловая система

**Внимание! В будущих версиях гипервизора при уточнениях требований заказчика эта информация может быть скорректирована.**

Вы имеете доступ к папкам операционной системы контейнера гипервизора. Однако, любые изменения файловой системы контейнера не будут сохранены при его перезапуске.

К контейнеру гипервизора также подключено несколько томов-папок (volumes), правила доступа к которым ограничены на уровне скрипта инициализации контейнера.

**/sources** - папка с файлами приложений Application Manager. Подключена в режиме только для чтения. (Если вы дадите к этой папке и доступ на запись, то python сможет автоматически создавать файлы .pyc со скомпилированным байт-кодом, которые при будут запускаться быстрее при повторных запусках)

**/workdirs** - папка рабочих директорий задач. При старте задачи для нее создается отдельная папка, где в качестве имени используется идентификационный номер задачи - pid. Вы можете хранить в этой папке собственные данные, необходимые при рассчетах и т.д. Эти файлы не стираются автоматически при перезапусках контейнера гипервизора. Вы также можете получить данные и из папок других задач, если знаете их pid, но это не всегда удобно или вообще возможно при работе.

**/venvs** - папка виртуальных окружений. Подробности работы с виртуальными окружениями будут описаны ниже в соответствующем разделе. На данный момент это просто папка с доступом на чтение и запись, в которой гипервизор создает и хранит виртуальные окружения python.

**/certs** - папка серфтификатов, необходимых для запуска сервисов, обслуживающих безопасные запросы на уровне доменного имени Application Manager. Данная папка будет полезна позже при внедрении функционала менеджмента внешних портов гипервизора. Доступ к этой папке есть только для чтения.

### Сетевое окружение

Вы можете запускать внутри контейнера любое количество серверов, обслуживающих только внутренний локальный сетевой интерфейс контейнера (127.0.0.1) на любых доступных портах. Таким образом, вы можете использовать любой доступный инструментарий python для работы с сетью, но пока только внутри контейнера. Вы также можете взаимодействовать с Apllication Manager, если знаете его архитектуру. 

Вы можете работать с внешними запросами к сетевым ресурсам - сайтам и серверам. Однако никто из внешней сети пока не может получить доступ к вашему серверу, написанному в виде скрипта и запущенному на гипервизоре. Этот функционал появится при добавлении гипервизору системы менеджемента внешних портов, который находится в процессе разработки. На текущий момент, если вы сами устанавливаете AM и гипервизор, то можете вручную прописать внешние порты для контейнера гипервизора в настройках docker-compose файла и работать с этим пулом портов в качестве внешних для своих сервисов, созданных на python.


## Особенности работы с python скриптами.

### Виртуальные окружения

Скрипты Python обычно исполняются в каком то "виртуальном окружении", в котором уже присутствует набор стандартных пакетов python.

Для удобства, в системе гипервизора для виртуальных окружений введено имя окружения - просто строка - название папки в томе виртуальных окружений /venvs.

В текущей версии при старте контейнера гипервизор создает одно общее виртуальное окружение (под именем default, оно задается через переменную окружения DEFAULT_VENV_NAME), в котором по-умолчанию будут запускаться все задачи python. Это поведение можно задать переменными окружения:

USE_VENV - переменная, указывающая гипервизору необходимость использования механизма отдельного виртуального окружения для задач. Может иметь значения True или False. По-умолчанию, имеет значение True. Сам гипервизор также написан на python. Механизм отдельных виртуальных окружений позволяет использовать гипервизору и задачам разные наборы дополнительных пакетов, чтобы не было сбоев и конфликтов.

DEFAULT_VENV_CLEAR_START - эта переменная указывает гипервизору, нужно ли ему принудительно пересоздавать общее виртуальное окружение задач при перезапуске контейнера. По-умолчанию имеет значение True. Это значит, что если вы доустановите в общее окружение какие то дополнительные пакеты (будет рассмотрено позже), они исчезнут при перезапуске гипервизора. Значение False позволяет гипервизору запускаться немного быстрее, так как он не создает окружение заново, если оно уже существует. Если окружения вообще еще не было создано, оно все равно будет создано при первом запуске в даже при значении False.

Есть еще несколько переменных окружения, влияющих на настройку режима работы виртуальных окружений:

VENVS_DIR - папка виртуальных окружений.
VENV_CREATION_TIMEOUT - таймаут времени создания виртуального окружения
VENV_WAIT_INTERVAL - интервал между попытками создания виртуального окружения.

### Общее виртуальное окружение default

Как было сказано ранее, гипервизор по-умолчанию запускает все задачи в общем виртуальном окружении default. При инициализации в него автоматически доустанавливаются пакеты, указанные в файле requirements.txt, которые использует и сам гипервизор для своей работы.

Вот их список на текущий момент:

- aiohttp==3.8.4
- aiojobs==1.1.0
- aiosignal==1.3.1
- async-timeout==4.0.2
- asyncio==3.4.3
- attrs==23.1.0
- charset-normalizer==3.1.0
- frozenlist==1.3.3
- idna==3.4
- lxml==4.9.3
- multidict==6.0.4
- procbridge==1.2.2
- psutil==5.9.5
- pytils==0.4.1
- selectors==0.0.14
- six==1.16.0
- user-agent==0.1.10
- weblib==0.1.30
- yarl==1.9.2

Этот список может быть изменен в будущих версиях или создан по-умолчанию отдельный. Вы всегда можете получить список пакетов, установленных на данный момент, об этом позже.

### Запуск задачи в выделенном виртуальном окружении.

Очень не редки случаи, когда у вас будут задачи, которые требуют отдельных версий пакетов, несовместимых друг с другом. Или вы не хотите замусоривать одно общее виртуальное окружение всеми возможными пакетами, которые используются всеми скриптами всех приложений с python скриптами.

Для этого в гипервизор был добавлен механизм выделенных виртуальных окружений. Вы можете создавать выделенное окружение и запускать скрипт (задачи) именно в нем с нужными версиями пакетов.

Есть два варианта создания или указания для гипервизора - в каком окружении запустить задачу.

#### 1. Выбор/создание выделенного виртуального окружения через параметры запуска задачи.

Как было сказано ранее, для маркировки виртуальных окружений используется имя - строка (подходящая под именование папки в файловой системе). 

Если в параметрах задачи указать параметр "venv_name" и имя окружения, то перед стартом задачи гипервизор попытается найти такое окружение в папки окружений (/venvs). 

Если такого окружения еще нет, гипервизор автоматически создаст его, но не будет ничего доустанавливать в него, как в случае с общим окружением задач. А затем запустит заданную задачу уже в этом пустом окружении.

Есть еще один параметр запуска, который может быть полезен при манипуляциях выделенными окружениями - "clean_venv". Он указывает гипервизору удалить среду после завершения задачи, если это не общая среда окружения задач. При указании его в параметрах при ручном запуске через АМ используйте значение true или false. При указании его в параметрах в коде Python при запуске дочерней задачи используйте True или False соответственно.

Если вы запускаете одновременно или так получается, что несколько задач используют одно выделенное виртуальное окружение в одно время и заданы параметры автоматического удаления этого окружения, то гипервизор удалит окружение только после завершения последней задачи.

** Внимание! Вы можете задать для выполнения задачи и общую среду окружения default, это пока никак не ограничено. Но делать это крайне не рекомендуется! Используйте для своих задач отдельные виртуальные окружения, если используете дополнительные пакеты при разработке. Это упростит разработку и поддержку в дальнейшем. **

**Примеры:**

Запустить задачу в выделенном виртуальном окружении venv1. Если его еще нет, будет создано пустое. Если уже существует - оно будет использовано.

![Использовать виртуальное окружение venv1 для задачи](images/python-user/image-18.png)

Запустить задачу в выделенном (создать его) виртуальном окружении venv1 и удалить его после завершения задачи:

![Использовать виртуальное окружение venv1 для задачи и удалить его после завершения задачи](images/python-user/image-19.png)

#### 2. Программный выбор/создание выделенного виртуального окружения.

На текущий момент в гипервизоре реализован начальный API для манипулирования виртуальными окружениями задач. 

Внимание! Этот функционал может изменяться со временем.

Вы можете импортировать в скрипт специальный класс из python модуля для манипулирования виртуальными окружениями appvenv:
```
from ompy.appmanager.appvenv import Venv
```
Это класс, с помощью которого можно создавать и удалять виртуальные окружения, доустанавливать нужные пакеты, также класс имеет некоторые полезные утилиты в виде методов класса.

После импорта класса вы можете использовать его как для создания нового окружения, так и "привязки" к существующему при инициализации.

Примеры кода:
```
from ompy.appmanager.appvenv import Venv

# создать или связать с переменной v виртуальное окружение venv1
v = Venv('venv1')

# вывести список пакетов, установленных в виртуальном окружении venv1
print(v.list())
# вывести список пакетов и их версий, установленных в виртуальном окружении venv1
print(v.list_spec())

# вывести значение переменной окружения USE_VENV
print(f'USE_VENV env variable: {Venv.get_env_value("USE_VENV")}')

# проверить на валидность имени для окружения значение ///
print(f'Is /// valid venv name?: {Venv.is_valid_venv_name("///")}')

# вывести список доступных виртуальных окружений
print(f'List of available venvs: {Venv.get_venvs()}')

# Удалить виртуальное окружение с помощью метода класса. После этого переменную v использовать нельзя или необходимо переинициализировать!
Venv.delete_venv('venv1')

# вывести список доступных виртуальных окружений
print(f'List of available venvs: {Venv.get_venvs()}')
```

Так это работает на текущий момент:

![Пример выполнения кода управления окружениями](images/python-user/image-20.png)

## Работа с локальными пакетами и модулями python.

### Импорт локальных модулей и пакетов

В приложении АМ вы можете создавать как файлы, так и папки. 

Таким образом, вы можете использовать функционал импорта из модулей или пакетов, обычно используемых в python.

Например, создайте такую структуру файлов и папок в приложении:

![Структура модулей](images/python-user/image-21.png)

У нас есть стартовый исполняемый файл test_import_local_module.py и два модуля, один из которых в пакете package со следующим содержимым:

test_import_local_module.py:
```
from module1 import module1_print
from package.module2 import module2_print

print('Test local module imports')
```

module1.py:
```
print('Imported module 1')

def module1_print():
    print('Print from module 1')
```

module2.py:
```
print('Imported module 2')

def module2_print():
    print('Print from module 2')
```

Результатом работы скрипта будет:

![Вывод консоли после запуска скрипта test_import_local_module.py](images/python-user/image-22.png)

## Установка дополнительных пакетов python.

Очень часто при создании приложений на Python нам необходимо доустанавливать какие то внешние пакеты других разработчиков.

В обычном случае на локальной машине чаще всего вы делаете это с помощью приложения модуля pip.

Вы можете запускать эту команду, используя модуль subprocess, но это не очень удобно, либо придется написать какой то удобный функционал самому.

На текущий момент в классе Venv, находящемся в модуле ompy.appmanager.appvenv, который мы уже использовали в разделе управления виртуальными окружениями реализован набор методов, упрощающих работу с установкой пакетов в привязанном виртуальном окружении обьекта. Также в этом классе есть набор статических методов класса, с помощью которых можно манипулировать установкой, но этот вариант не рекомендуется использовать.

Пример установки пакета requests (скрипт test_venv_package_install.py в приложении Manual):

```
from ompy.appmanager.appvenv import Venv

# создаем новое или используем какое то существующее виртуальное окружение some_venv
v = Venv('some_venv')

# выводим список пакетов, уже установленных в этом окружении на печать
print(v.list())

# установим пакет requests в это окружение
v.install_latest('requests')

# проверим, что установка пакета requests и его зависимостей прошла успешно
print(v.list_spec())

v.install('requests', spec='==2.1')

# проверим версии пакетов
print(v.list_spec())
```

Метод install_latest установит самый свежий вариант пакета. Метод install без указания спецификатора установит свежую или не будет устанавливать пакет, если любая его версия уже есть в окружении. Указав опциональный параметр spec, вы можете установить нужную вам версию пакета.

Если в процессе установки произойдет ошибка, будет выброшено исключение. В этом коде мы рассматриваем идеальный случай, эта ситуация не обрабатывается.

Методов удаления пакетов из виртуального окружения в классе пока нет. Если вы устанавливает версию пакета, несовпадающую с уже установленной, pip сам должен удалить другую версию пакета. Все как и при использовании обычного pip.

# Запуск дочерних python задач

В AM предусмотрен функционал, когда одна задача может запустить другую задачу.

Этот механизм использует термины "родительская" - запускающая задача и "дочерняя" - задача, запускаемая из родительской.

Родительская задача посылает АМ специальный IPC-пакет для запуска дочерней задачи и уже АМ запускает эту задачу, как дочернюю, передавая ей также соответствующие параметры.

Это позволяет нам запускать из одной задачи какой то связанный или совершенно независимый функционал другого скрипта.

Можно придумать множество примеров использования такого механизма.

Самый простой случай - создание каких то загрузчиков. Например, родительская задача может подготовить нужное виртуальное окружение, установить в него необходимые версии пакетов, а затем - запустить уже дочернюю задачу, которая может работать в окружении с этой подготовленной средой.

Вы также можете создавать загрузчики, которые и не запускают дочерние задачи, а работают независимо, подготавливая нужную среду для других задач. Механизм дочерних задач просто хорошо вписывается в этот рабочий процесс, так как обычно не рекомендуется устанавливать новые пакеты и работать с ними в одном скрипте-задаче, а дочерняя задача запускается как отдельный новый процесс и позволяет сделать нам "чистый" запуск с уже установленными пакетами.

Для запуска дочерней задачи нам нужно знать идентификатор скрипта или его имя. Вот простой пример запуска дочерней задачи (child.py) из родительской задачи (parent.py):

child.py:
```
print('Print from child')
```

parent.py:
```
from ompy.appmanager.communication import run_am_script

script_id = 'child.py'
script_params = {}
print(f"Запуск дочерней задачи из скрипта '{script_id}' "
      f"с параметрами '{script_params}'")
child_pid = run_am_script(script_id, script_params)

print(child_pid)

print('Завершение родительской задачи')
```

Результат запуска скрипта parent.py в консоли АМ:

![Запуск дочернего скрипта. Вывод консоли АМ](images/python-user/image-23.png)

Как вы можете заметить, при запуске дочерней задачи, run_am_script возвращает pid задачи дочернего процесса.

Дочерняя задача может продолжать работу даже после завершения родительской.

**Важно! Дочерняя задача также должна быть помечена, как исполняемая для успешного запуска! Это поведение отличается от импорта локальных модулей, которые могут не быть помечены как исполняемые, так как импорт осуществляет процесс одного интерпретатора одной задачи.**

Механизм запуска дочерних задач в данный момент реализован в виде простой функции модуля ompy.appmanager.communication. В будущем при разработке API для приложений на python (по желанию заказчика) метод запуска дочерних задач может быть изменен.


### Обмен данными между задачами.

Как было сказано ранее в разделах о файловой системе и сетевом окружении - вы можете создавать собственные механизмы обмена данными между задачами или сервисами, которые будете реализовывать в виде скриптов приложений. Вы даже можете запускать скрипты с помощью стандарного модуля subprocess как бы "в обход" Application Manager, пока это никак не ограничивается в гипервизоре внешних задач.

Представим, что у вас есть скрипт или программа, которую вы хотите запустить с входными параметрами и получить ее вывод из стандартного потока при завершении. В нашем случае - будем использовать скрипт на python, который получает параметр рассчета факториала из входного аргумента и возвращает результат, распечатав его.

Вот пример такого простого скрипта (test_sub.py):

```
import sys
import math

number = int(sys.argv[1])
result = math.factorial(number)
print(result)
```
Код очень упрощен, показан лишь для демонстрации возможности. Заметим, что на текущий момент даже нет необходимости делать этот файл исполняемым в AM. Все запустится и без этого.

Пример основной задачи, которая запускает test_sub.py и получает результат (test_run_sub.py):
```
import subprocess
import os
from ompy.appmanager.variables import TASK_PARAMS

def calculate_factorial(number):
    command = ["python", os.path.join(TASK_PARAMS['applicationPath'], "test_sub.py"), str(number)]
    result = subprocess.check_output(command).decode("utf-8").strip()
    return int(result)


input_number = 5
factorial_result = calculate_factorial(input_number)
print(f"Factorial of {input_number} is: {factorial_result}")
```
Здесь мы использовали переменную TASK_PARAMS['applicationPath'], чтобы получить путь к папке с исходными файлами приложения. А затем запустили этот скрипт с помощью модуля subprocess и извлекли результат из его вывода консоли.

Конечно, такой код будет работать и очень быстро, так как пока для этого нет никакого контроля. Все эти процессы будут работать внутри контейнера гипервизора и не "вырвутся" из него. Возможно, это как то будет ограничено позже. На данный момент - такая возможность есть.

Архитектурно в AM закладываются методы обмена задач данными друг с другом через AM. Этот функционал пока не реализован для внешних задач в виде какого либо API.

На текущий момент в гипервизоре есть реализованный функционал в виде простого API, позволяющий обмениваться данными только между python-задачами, например, между дочерней и родительской задачами. Вы можете обмениваться данными с задачей, зная ее pid-идентификатор, а в случае с дочерними задачами - мы получаем его при запуске из родительской задачи. 

В будущем возможна реализация обмена данными между задачами любого языка через механизм вэбсокетов Application Manager.

В текущей реализации взаимодействие между python задачами реализовано через "мост" данных вэбсокет-сокет. При старте задачи гипервизор ожидает запрос вэбсокет-соединения по адресу 0.0.0.0:RESOURCE_SERVER_LOCAL_PORT/pid
где RESOURCE_SERVER_LOCAL_PORT - порт локального вэбсокет сервера гипервизора, значение которого на текущий момент 18564 - установлено в переменной окружения, а pid - идентификатор задачи. 

Одна задача может подключиться к вэбсокет адресу другой задачи и отправить в него данные. Эти данные будут переданы гипервизором в unix-сокет задачи с этим pid. В свою очередь, задача может ожидать такое подключение на своем сокете и принимать данные по нему от другой задачи.

**Этот функционал обмена может быть изменен в будущих версиях проекта!**

С помощью этого функционала python задачи могут обмениваться друг с другом данными в бинарном или текстовом виде.

### Пример взаимодействия между python-задачами через вэбсокет-сокет задачи.

Допустим, у нас есть задача, рассчитывающая факториал числа, который она получает из своих параметров запуска, передаваемых ей от Application Manager.

Для работы с параметрами, которые получают задачи, а также для получения информации о переменных окружения в API python-гипервизора реализован модуль ompy.appmanager.variables из которого вы можете получить множество полезных значений, среди которых есть и TASK_PARAMS - словарь со значениями параметров, передаваемых задаче. Пример этого словаря при запуске задачи без дополнительных параметров (запуск задачи из панели управления кнопкой Run Script):

{'pid': '94edcac2-3529-4699-8468-d3a0c00696c2', 'parentPid': None, 'applicationPath': '/sources/Manual-N9IBvh', 'scriptPath': 'test_data_exchange_parent.py', 'scriptParams': {}, 'outputPath': '/workdirs/94edcac2-3529-4699-8468-d3a0c00696c2'}

По-умолчанию все задачи получают в этом словаре данные о своем идентификаторе pid, родительском идентификаторе, если эта задача запущена как дочерняя - parentPid, путь к папке с исходными файлами код скрипта приложения в контейнере - applicationPath, путь к скрипту - scriptPath, параметры, передаваемые скрипту пользователем при ручном запуске или программном запуске как параметры задачи - scriptParams, а также рабочая директория задачи - outputPath.

Если мы хотим получать параметр из пользовательских параметров задачи, нам надо получать его из словаря scriptParams.

Пример взаимодействия задач через вэб-сокеты-сокеты.

Пример дочерней задачи (test_data_exchange_child.py).
```
import asyncio, aiohttp
import math
from ompy.appmanager.variables import TASK_PARAMS


async def main():
    factorial_param = TASK_PARAMS['scriptParams'].get("factorial", None)

    if not factorial_param is None:
        print(f'Рассчет факториала числа {factorial_param} в дочерней задаче')
        if not TASK_PARAMS["parentPid"] is None:
            print(f'PID родительской задачи: {TASK_PARAMS["parentPid"]}')
            WS_URL = f'http://127.0.0.1:18564/{TASK_PARAMS["parentPid"]}'
            print(f'Адрес вэбсокета сокета родительской задачи: {WS_URL}')
            async with aiohttp.ClientSession() as session:
                async with session.ws_connect(WS_URL) as ws:
                    result = math.factorial(factorial_param)
                    await ws.send_str(f'result is {result}')
                    print(f'Результат рассчета факториала {result} отправлен родительской в вэбсокет->сокет задаче')


asyncio.run(main())
```

Пример родительской задачи, запускающей дочернюю и ожидающий от нее результат:
```
from ompy.appmanager.communication import run_am_script, wait_for_socket_from_web
from ompy.appmanager.observer import read_json_from_observer

script_id = 'test_data_exchange_child.py'
script_params = {'factorial': 5}
print(f"Запуск дочерней задачи рассчета факториала из скрипта '{script_id}' "
      f"с параметрами '{script_params}'")
child_pid = run_am_script(script_id, script_params)

print('Ожидаем результат от дочерней задачи')
soc = wait_for_socket_from_web()
message = soc.sync_read_text_message()
print(f'Получен результат из дочерней задачи: {message}')
soc.sync_close()

print('Завершение родительской задачи')
```

Родительская задача запускает дочернюю с параметром {"factorial": 5}, а затем ожидает подключения "к себе" извне по вэбсокету.wait_for_socket_from_web возвращает экземпляр сокета, из которого могут быть получены данные с помощью синхронного метода sync_read_text_message.

Методы взаимодействия задач - самая интересная и сложная тема. Пока что какой то API функционал находится в минимальном виде, однако никак не ограничивая вас.

Это руководство будет дополняться и изменяться и, возможно, будет оформлено в другом формате для удобства чтения и поиска информации позже.